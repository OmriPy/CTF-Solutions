# Exploit:
```
./mistake
FFFFFFFFFF
input password : GGGGGGGGGG
```
## Explanation:
The code xors our input by 1 (`xor input, 1`).
So I checked what is the result of `xor 0x46, 1` (0x46 = F). And the result was 0x47 which is G.
Also, we know that the code only takes 10 bytes and each ascii character is 1 byte so I entered 10 times F and 10 times G.
So, we understand that because `xor 0x46, 1 = 0x47` (`xor F, 1 = G`), the `strncmp` function returned 0 which means the strings are equal.

But why in the first place did the executable ask for input twice? `scanf` appears in the code once.
That's because "somehow" the value of `fd` was 0. And 0 represents `stdin`. This is why the `read` function asked for input from the user.

So why in the first place was the value of the `fd` variable 0? That's because if it wasn't, the program would have terminated earlier. Why? Let's take a look at our first if statement in the code:

```c
int fd;
if(fd=open("/home/mistake/password",O_RDONLY,0400) < 0){
	printf("can't open password %d\n", fd);
	return 0;
}
```
We can see that `fd` gets the return value of the `open` function, right? No. Why? Because of Operator Priority/Precedence. There are some operators which will be execuated before others. In our case, the `<` operator has higher priority than the `=` operator. So, `fd` gets the value of the condition:
```c
open("/home/mistake/password",O_RDONLY,0400) < 0
```
which is false because the file "password" exists so `open` would return a non-negative number. Which means the condition is false, which means `fd` will be 0.
